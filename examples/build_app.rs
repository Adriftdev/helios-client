use helios_client::dsl::{HttpMethod, PipelineBuilder}; // Assuming dsl.rs has these
// Use statements for types generated by graphql_client inside client.rs
use helios_client::client::run_pipeline; // Import the generated module

use helios_client::dsl::StepCallback;
use helios_client::{HeliosClientError, HeliosGraphQLClient};
use std::collections::HashMap; // Import the callback type alias

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Define GraphQL server endpoint
    let graphql_endpoint = "http://localhost:8000/api/graphql"; // Replace with your actual endpoint

    println!("Building pipeline definition...");

    // 2. Build the pipeline using the DSL
    let (pipeline_input, _): (run_pipeline::PipelineInput, HashMap<String, StepCallback>) =
        PipelineBuilder::new("pipeline-via-gql-001")
            .webhook("turn_on_pump_indoor", "http://adriftdev.ddns.net/")
            .method(HttpMethod::POST)
            .header("Content-Type", "application/json")
            .body(&r#"{"prompt": "Turn on the pump"}"#)
            .then()
            .output("turn_on_pump_indoor")
            .build();

    // 3. Create the GraphQL Client
    // Use new or connect based on your preference/implementation
    let client = HeliosGraphQLClient::new(graphql_endpoint.to_string());
    // Or: let client = HeliosGraphQLClient::connect(graphql_endpoint).await?;
    println!("GraphQL client created for endpoint: {}", graphql_endpoint);

    // 4. Execute the GraphQL Mutation
    println!("Sending RunPipeline mutation...");
    match client.run_pipeline(pipeline_input, None).await {
        Ok(response_data) => {
            // response_data is the generated run_pipeline::RunPipelineRunPipeline struct
            println!("\n=== GraphQL Response Received ===");
            println!("Success: {}", response_data.success);
            println!("Message: {}", response_data.message);

            if response_data.outputs.is_empty() {
                println!("Outputs: (None requested or produced)");
            } else {
                println!("Outputs:");
                // Iterate through the outputs received
                for output in &response_data.outputs {
                    // output is the generated run_pipeline::RunPipelineRunPipelineOutputs struct

                    println!("  - Step ID: {}", output.step_id);
                    println!("    Result JSON: {}", output.result_json);
                    if let Some(err) = &output.error {
                        println!("    Error: {}", err);
                    }
                }
            }
            println!("===============================\n");
        }
        Err(e) => {
            eprintln!("\n--- Error running pipeline ---");
            eprintln!("{}", e);
            // Specific handling for different errors if needed
            match e {
                HeliosClientError::Request(req_err) => {
                    // Handle HTTP request error
                    eprintln!("Underlying HTTP error: {:?}", req_err);
                }
                HeliosClientError::GraphQL(gql_errors) => {
                    // Handle errors returned by the GraphQL server itself
                    for err in gql_errors {
                        eprintln!("GraphQL Error: {}", err.message);
                        // You can inspect err.locations, err.path, err.extensions
                    }
                }
                HeliosClientError::Deserialization(serde_err) => {
                    // Handle error parsing the response from the server
                    eprintln!("Response JSON parsing error: {:?}", serde_err);
                }
                HeliosClientError::NoData => {
                    eprintln!("Server returned null data field in response.");
                }

                HeliosClientError::GenericError(msg) => {
                    // Handle any other generic error
                    eprintln!("Generic error: {}", msg);
                }

                _ => {
                    // Handle any other specific error types you may have
                    eprintln!("Other error: {:?}", e);
                }
            }
            println!("----------------------------\n");
        }
    }

    Ok(())
}
