pub mod client;
pub mod dsl;

// src/client.rs (or wherever you put the client)

use std::collections::HashMap;

use client::{
    RunPipelineResponseData,
    run_pipeline::{self, PipelineInput},
};
use dsl::StepCallback;
use reqwest::Client;
use serde_json::Value;
use thiserror::Error;

// Re-export or define types needed by users
pub use crate::dsl::PipelineBuilder; // Adjust path
// Bring in the GraphQL specific types needed for the client method signature/return
use crate::client::{
    // Defined above for DSL build result
    RunPipeline, // Generated by graphql_client
};
use graphql_client::{GraphQLQuery, Response as GraphQLResponse}; // GraphQL types

#[derive(Error, Debug)]
pub enum HeliosClientError {
    #[error("HTTP request failed: {0}")]
    Request(#[from] reqwest::Error),
    #[error("GraphQL request failed: {0:?}")]
    GraphQL(Vec<graphql_client::Error>),
    #[error("Failed to deserialize response: {0}")]
    Deserialization(#[from] serde_json::Error),
    #[error("No data received from GraphQL response")]
    NoData,
    #[error("Invalid response format")]
    InvalidResponseFormat,

    #[error("Invalid pipeline input: {0}")]
    GenericError(String),
}

#[derive(Clone)] // Add clone if needed
pub struct HeliosGraphQLClient {
    endpoint: String,
    http_client: Client,
}

impl HeliosGraphQLClient {
    /// Creates a new client instance.
    pub fn new(endpoint: String) -> Self {
        Self {
            endpoint,
            http_client: Client::new(), // Create a reqwest client
        }
    }

    /// Connect (alternative constructor, maybe less needed now)
    pub async fn connect(endpoint: &str) -> Result<Self, HeliosClientError> {
        // Basic connect, no TLS specific config here, reqwest handles defaults
        Ok(Self::new(endpoint.to_string()))
    }

    /// Runs the pipeline via GraphQL mutation.
    pub async fn run_pipeline(
        &self, // Changed to &self, no need for &mut self
        pipeline: PipelineInput,
        // Optional: Pass callbacks if you want the client to handle them
        callbacks: Option<HashMap<String, StepCallback>>,
    ) -> Result<run_pipeline::RunPipelineRunPipeline, HeliosClientError> {
        // Return client-specific struct

        let variables = run_pipeline::Variables {
            pipeline_input: pipeline, // Pass the PipelineInput built by the DSL
        };

        let request_body = RunPipeline::build_query(variables);

        let res = self
            .http_client
            .post(&self.endpoint)
            .json(&request_body) // Send query/variables as JSON
            .send()
            .await?;

        // Check for HTTP errors first
        let status = res.status();
        if !status.is_success() {
            // Read body for more details if possible
            let error_body = res
                .text()
                .await
                .unwrap_or_else(|_| "Failed to read error body".to_string());

            return Err(HeliosClientError::GenericError(format!(
                "HTTP error: {} - {}",
                status, error_body
            )));
        }

        // Deserialize the response using graphql_client's Response struct
        let response_body: GraphQLResponse<RunPipelineResponseData> = res.json().await?;

        // Check for GraphQL errors reported in the response body
        if let Some(errors) = response_body.errors {
            return Err(HeliosClientError::GraphQL(errors));
        }

        // Extract the actual data
        // The data field name 'runPipeline' comes from the mutation definition
        let response_data = response_body.data.ok_or(HeliosClientError::NoData)?;

        // Map the generated response type to your client-specific response type
        // (This assumes run_pipeline_mutation::RunPipeline exists within ResponseData)
        let run_pipeline_data = response_data.run_pipeline; // Access the specific mutation result field

        // Trigger callbacks here if needed, using run_pipeline_data.outputs
        if let Some(mut callback_map) = callbacks {
            for output in &run_pipeline_data.outputs {
                if let Some(callback) = callback_map.remove(&output.step_id) {
                    // Attempt to parse result_json before calling callback
                    let result_value: Value = serde_json::from_str(&output.result_json)
                        .unwrap_or_else(|_| {
                            Value::String(format!("Error parsing result: {}", output.result_json))
                        });
                    callback(result_value);
                }
            }
        }

        // Return the structured data

        Ok(run_pipeline_data) // Return the structured data    
    }
}
